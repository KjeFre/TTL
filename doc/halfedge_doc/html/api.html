<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>The Half-Edge Data Structure and Adaption to TTL - Brief Reference Manual</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="qindex">
<a class="qindexHL" href="index.html">Main&nbsp;Page</a> | 
<a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | 
<a class="qindex" href="annotated.html">Compound&nbsp;List</a> | 
<a class="qindex" href="files.html">File&nbsp;List</a> | 
<a class="qindex" href="functions.html">Compound&nbsp;Members</a> | 
<a class="qindex" href="pages.html">Related&nbsp;Pages</a>
</div>
</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<h1><a class="anchor" name="api">Application Programming Interface to TTL (API)</a></h1>There are two interface channels between TTL and the application data structure: <a class="el" href="api.html#darttypesec">DartType</a> and <a class="el" href="api.html#traitstypesec">TraitsType</a>, which are template arguments to the TTL functions. Function templates in TTL use either <code>DartType</code> or both <code>DartType</code> and <code>TraitsType</code> depending on the complexity of the algorithms. <code>DartType</code> is used for topological queries, and <code>TraitsType</code> is used for topological modifiers and geometric calculations. The documentation in TTL tells which functionality is needed in <code>DartType</code> and <code>TraitsType</code> for each function template.<p>
TTL consists of two namespaces with generic functions: <a class="elRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl.html">ttl</a> contains the main interface and <a class="elRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl__util.html">ttl_util</a> contains utility functions that can also be used by the application programmer. The figure below shows the (simple) architecture of an application using TTL.<p>
<div align="center">
<img src="api.gif" alt="api.gif">
</div>
<p>
In the following we explain how <code>DartType</code> and <code>TraitsType</code> must be implemented as an interface to the actual data structure. For more details see <a href="../../ttl_doc/html/index.html#publications">literature</a>.<h2><a class="anchor" name="darttypesec">
DartType</a></h2>
The generic functions in TTL navigates in the application data structure through a "topological element" call a <em>dart</em>, which must be implemented as a struct or a class by the application programmer. A dart can be considered as a unique triple <em>d</em> = (<em>V</em>, <em>E</em>, <em>T</em>), where <em>V</em> is a node of the edge <em>E</em>, and <em>V</em> and <em>E</em> is a node and an edge of the triangle <em>T</em>; see figure a) below where a dart is indicated as an arrow.<p>
<div align="center">
<img src="dart.gif" alt="dart.gif">
</div>
<p>
TTL expects that three functions, which we call <em>alpha-iterators</em>, are present in the dart class: <code>alpha0()</code>, <code>alpha1()</code> and <code>alpha2()</code>. These functions reposition the dart in the triangulation as shown in figure b) above and return a reference to the modified dart itself. Thus, <code>alpha0()</code>, <code>alpha1()</code> and <code>alpha2()</code> change the node, the edge and the triangle of the triple <em>d</em> = (<em>V</em>, <em>E</em>, <em>T</em>) respectively.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li>The <em>dart</em> is not part of the data structure. It is a "dynamic" element that "moves" around in the actual application data structure when the alpha-iterators are applied to it. Thus, this mechanism does not require any extra memory other than that occupied by the (few) darts that are involved in a function template of TTL that is called.</li></ul>
</dd></dl>
In addition to the alpha-iterators, TTL expects that standard class member functions such as constructors, assignment operators and the like are also implemented in the dart class.<p>
The following syntax is required:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyDart {
  ...
public:
  <span class="comment">// Constructors and destructors</span>
  ...
  MyDart(<span class="keyword">const</span> MyDart&amp; dart) {...} <span class="comment">// copy constructor</span>
  MyDart&amp; operator= (<span class="keyword">const</span> MyDart&amp; dart) {...} <span class="comment">// assignment operator</span>

  <span class="comment">// comparing dart objects</span>
  <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> MyDart&amp; dart)<span class="keyword"> const </span>{...}
  <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> MyDart&amp; dart)<span class="keyword"> const </span>{...}

  <span class="comment">// alpha-iterators</span>
  MyDart&amp; alpha0() {...; <span class="keywordflow">return</span> *<span class="keyword">this</span>;}
  MyDart&amp; alpha1() {...; <span class="keywordflow">return</span> *<span class="keyword">this</span>;}
  MyDart&amp; alpha2() {...; <span class="keywordflow">return</span> *<span class="keyword">this</span>;}
  };
</pre></div><p>
Thus, the alpha-iterators change the content of the dart and return a reference to the dart itself.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li>Note that <code>alpha2()</code> must return the dart itself without changing its content (when checked with the <code>==</code> operator) if the edge associated with the dart is at the boundary of the triangulation. The source code of <a class="elRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl.html#0005ecaf3d54298da01be64ea6b474a8">ttl::isBoundaryEdge</a> illustrates this:</li></ul>
</dd></dl>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span> &lt;<span class="keyword">class</span> DartType&gt;
  <span class="keywordtype">bool</span> <a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl.html#0005ecaf3d54298da01be64ea6b474a8">isBoundaryEdge</a>(<span class="keyword">const</span> DartType&amp; dart) {
    
  DartType dart_iter = dart;
  <span class="keywordflow">if</span> (dart_iter.alpha2() == dart)
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div><p>
Consult the definition and source code of class <a class="el" href="classhed_1_1Dart.html">hed::Dart</a>, which implements the dart class for the half-edge data structure, for a thorough example.<h2><a class="anchor" name="traitstypesec">
TraitsType</a></h2>
<code>TraitsType</code> can be a static class or a struct that contains functionality required by the functions in TTL. The purpose with <code>TraitsType</code> is twofold:<ul>
<li>Let the application programmer provide topological modifiers on the actual data structure that are not resolved by TTL, e.g., remove a triangle from the triangulation,</li><li>Let the application programmer provide basic geometric calculations and thus control the level of accuracy for such calculations.</li></ul>
<p>
For example, assume that a function in TTL requires a scalar product between vectors in the plane, represented as darts, with the following syntax:<p>
<div class="fragment"><pre class="fragment">real_type <a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl__util.html#f0c7fb2a62351f6d6d2e309d976e55d4">scalarProduct2d</a>(<span class="keyword">const</span> DartType&amp; d1, <span class="keyword">const</span> DartType&amp; d2)
</pre></div><p>
Then this function must be implemented in the traits class together with the definition of <code>real_type:</code> <p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyTraitsType {
  <span class="keyword">typedef</span> <span class="keywordtype">double</span> real_type;
  ...
  <span class="keyword">static</span> real_type <a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl__util.html#f0c7fb2a62351f6d6d2e309d976e55d4">scalarProduct2d</a>(<span class="keyword">const</span> MyDart&amp; v1, <span class="keyword">const</span> MyDart&amp; v2) {
    return ::my_scalarProduct2d(v1,v2);
  }
  ...
  <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl.html#1cb871915e3fbcf5f4e25079a7500f0c">swapTestDelaunay</a>(<span class="keyword">const</span> MyDart&amp; dart) {
    <span class="keywordflow">if</span> (dart.getEdge().isConstrained())
      <span class="keywordflow">return</span> <span class="keyword">false</span>;
    <span class="keywordflow">else</span>
      <span class="keywordflow">return</span> ttl::swapTestDelaunay&lt;MyTraitsType&gt;(dart);
  }
};
</pre></div><p>
The second function, <code>swapTestDelaunay</code>, implements the Delaunay swapping test. The function desides if the edge associated with the given dart should be swapped according to the <em>circumcircle</em> criterion (or equivalently according to the <em>MaxMin</em> angle criterion). In the example above, it is first examined if the edge is constrained, in which case false is returned. Then the test is directed back to TTL again since the circumcircle test is present there; see <a class="elRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl.html#1cb871915e3fbcf5f4e25079a7500f0c">ttl::swapTestDelaunay</a>. Of course, the user could also make his/her own implementation of the circumcircle test, e.g., by using robust schemes with exact arithmetic as Jonathan Richard Shewchuk does (<a href="http://www-2.cs.cmu.edu/~quake/robust.html">http://www-2.cs.cmu.edu/~quake/robust.html</a>).<p>
This example also illustrates the syntax <code>functionName&lt;MyTraitsType&gt;</code>(...arguments...) when calling function templates using a traits class.<p>
Actually, scalar product between vectors, as well as cross product and other point and vector algebra, are also present in the the namespace <a class="elRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl__util.html">ttl_util</a>. Assume that <code>MyDart::x()</code> and <code>MyDart::y()</code> deliver the coordinates in the plane of the node associated with a dart. Then the scalar product in <code>MyTraitsType</code> can be implementes as:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> real_type <a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl__util.html#f0c7fb2a62351f6d6d2e309d976e55d4">scalarProduct2d</a>(<span class="keyword">const</span> MyDart&amp; v1, <span class="keyword">const</span> MyDart&amp; v2) {
  MyDart v10 = v1; v10.alpha0();
  Dart v20 = v2; v20.alpha0();
  <span class="keywordflow">return</span> <a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl__util.html#f0c7fb2a62351f6d6d2e309d976e55d4">ttl_util::scalarProduct2d</a>(v10.x()-v1.x(), v10.y()-v1.y(), 
                                   v20.x()-v2.x(), v20.y()-v2.y());
}
</pre></div><p>
Consult the definition and source code of struct <a class="el" href="structhed_1_1TTLtraits.html">hed::TTLtraits</a>, which implements the traits class for the half-edge data structure. This example shows which members that are required in the traits class for running incremental Delaunay triangulation and removing nodes in a triangulation. <hr size="1"><address style="align: right;"><small>Generated on Wed Sep 19 15:15:01 2007 for Half-Edge by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
