<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>The Half-Edge Data Structure and Adaption to TTL - Brief Reference Manual</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="qindex">
<a class="qindexHL" href="index.html">Main&nbsp;Page</a> | 
<a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | 
<a class="qindex" href="annotated.html">Compound&nbsp;List</a> | 
<a class="qindex" href="files.html">File&nbsp;List</a> | 
<a class="qindex" href="functions.html">Compound&nbsp;Members</a> | 
<a class="qindex" href="pages.html">Related&nbsp;Pages</a>
</div>
</body>
</html>
<!-- Generated by Doxygen 1.5.1 -->
<h1><a class="anchor" name="hesimplest">Example using TTL and the half-edge data structure</a></h1><div class="fragment"><pre class="fragment"><span class="comment">//==================================================================================================</span>
<span class="comment">//</span>
<span class="comment">// File: main.cpp</span>
<span class="comment">//</span>
<span class="comment">// Created:</span>
<span class="comment">//</span>
<span class="comment">// Author: Øyvind Hjelle &lt;oyvind.hjelle@math.sintef.no&gt;</span>
<span class="comment">//</span>
<span class="comment">// Revision: $Id: hesimplest.html,v 1.6 2007/09/19 13:17:26 oyvindhj Exp $</span>
<span class="comment">//</span>
<span class="comment">// Description:</span>
<span class="comment">//</span>
<span class="comment">//==================================================================================================</span>
<span class="comment">// Copyright (C) 2000-2003 SINTEF Applied Mathematics.  All rights reserved.</span>
<span class="comment">//</span>
<span class="comment">// This file is part of an example program for TTL.  This example</span>
<span class="comment">// program may be used, distributed and modified without limitation.</span>
<span class="comment">//</span>
<span class="comment">//==================================================================================================</span>



<span class="comment">//#define DEBUG_TTL_CONSTR</span>
<span class="comment">//#define DEBUG_TTL_CONSTR_PLOT</span>

<span class="preprocessor">#include &lt;HeTriang.h&gt;</span>
<span class="preprocessor">#include &lt;HeDart.h&gt;</span>
<span class="preprocessor">#include &lt;HeTraits.h&gt;</span>
<span class="comment">//using namespace hed; // (to avoid using prefix hed::)</span>

<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="keyword">using namespace </span>std;


<span class="comment">// ------------------------------------------------------------------------------------------------</span>
<span class="comment">// Interpret two points as being coincident</span>
<span class="keyword">inline</span> <span class="keywordtype">bool</span> eqPoints(<a class="code" href="classhed_1_1Node.html">hed::Node</a>*&amp; p1, <a class="code" href="classhed_1_1Node.html">hed::Node</a>*&amp; p2) {
  <span class="keywordtype">double</span> dx = p1-&gt;<a class="code" href="classhed_1_1Node.html#a6943d021752154c5c735183e13270b8">x</a>() - p2-&gt;<a class="code" href="classhed_1_1Node.html#a6943d021752154c5c735183e13270b8">x</a>();
  <span class="keywordtype">double</span> dy = p1-&gt;<a class="code" href="classhed_1_1Node.html#df7d4625b6fe5019049f5bd6002e210f">y</a>() - p2-&gt;<a class="code" href="classhed_1_1Node.html#df7d4625b6fe5019049f5bd6002e210f">y</a>();
  <span class="keywordtype">double</span> dist2 = dx*dx + dy*dy;
  <span class="keyword">const</span> <span class="keywordtype">double</span> eps = 1.0e-12;
  <span class="keywordflow">if</span> (dist2 &lt; eps)
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
  
  <span class="keywordflow">return</span> <span class="keyword">false</span>;
}


<span class="comment">// ------------------------------------------------------------------------------------------------</span>
<span class="comment">// Lexicographically compare two points (2D)</span>
<span class="keyword">inline</span> <span class="keywordtype">bool</span> ltLexPoint(<span class="keyword">const</span> <a class="code" href="classhed_1_1Node.html">hed::Node</a>* p1, <span class="keyword">const</span> <a class="code" href="classhed_1_1Node.html">hed::Node</a>* p2) {  
  <span class="keywordflow">return</span> (p1-&gt;<a class="code" href="classhed_1_1Node.html#a6943d021752154c5c735183e13270b8">x</a>() &lt; p2-&gt;<a class="code" href="classhed_1_1Node.html#a6943d021752154c5c735183e13270b8">x</a>()) || (p1-&gt;<a class="code" href="classhed_1_1Node.html#a6943d021752154c5c735183e13270b8">x</a>() == p2-&gt;<a class="code" href="classhed_1_1Node.html#a6943d021752154c5c735183e13270b8">x</a>() &amp;&amp; p1-&gt;<a class="code" href="classhed_1_1Node.html#df7d4625b6fe5019049f5bd6002e210f">y</a>() &lt; p2-&gt;<a class="code" href="classhed_1_1Node.html#df7d4625b6fe5019049f5bd6002e210f">y</a>());
};


<span class="comment">// =================================================================================================</span>
<span class="comment">// A main program using TTL and the half-edge data structure to create</span>
<span class="comment">// a Delaunay triangulation.</span>
<span class="comment">// The program also demonstrates how to use other function templates in TTL.</span>
<span class="comment">// =================================================================================================</span>

<span class="keywordtype">int</span> main() {
  
  <span class="comment">// ===============================================================</span>
  <span class="comment">// CREATE A DELAUNAY TRIANGULATION FROM RANDOM POINTS IN THE PLANE</span>
  <span class="comment">// ===============================================================</span>
  
  <span class="comment">// Create random test data.</span>
  <span class="keywordtype">int</span> no_of_nodes = 100;
  std::vector&lt;hed::Node*&gt;* nodes = ttl_util::createRandomData&lt;hed::Node&gt;(no_of_nodes);

  <span class="comment">// Sort the nodes lexicographically in the plane.</span>
  <span class="comment">// This is recommended since the triangulation algorithm will run much faster.</span>
  <span class="comment">// (ltLexPoint is defined above)</span>
  std::sort(nodes-&gt;begin(), nodes-&gt;end(), ltLexPoint);
  
  <span class="comment">// Remove coincident points to avoid degenerate triangles. (eqPoints is defined above)</span>
  std::vector&lt;hed::Node*&gt;::iterator new_end = std::unique(nodes-&gt;begin(), nodes-&gt;end(), eqPoints);
  
  <span class="comment">// Make the triangulation</span>
  <a class="code" href="classhed_1_1Triangulation.html">hed::Triangulation</a> triang;
  triang.createDelaunay(nodes-&gt;begin(), new_end);
  
  <span class="comment">// &lt;... Print triangulation; see end of file ...&gt;</span>
  
  <span class="comment">// ========================================================</span>
  <span class="comment">// SOME EXAMPLES USING TTL (Functions in namespace ttl)</span>
  <span class="comment">// ========================================================</span>
  
  <span class="comment">// Insert a new node in the Delaunay triangulation.</span>
  <span class="comment">// We need an arbitrary CCW (counterclockwise) dart for TTL.</span>
  <span class="comment">// Make the dart from the first edge in the list of leading edges.</span>
  <span class="comment">// ( Could also use Triangulation::createDart() )</span>
  <span class="keyword">const</span> list&lt;hed::Edge*&gt;&amp; l_edges = triang.getLeadingEdges();
  <a class="code" href="classhed_1_1Edge.html">hed::Edge</a>* edge = *l_edges.begin();
  <a class="code" href="classhed_1_1Dart.html">hed::Dart</a> dart(edge);
  <a class="code" href="classhed_1_1Node.html">hed::Node</a>* point = <span class="keyword">new</span> <a class="code" href="classhed_1_1Node.html">hed::Node</a>(0.3, 0.6, 0);
  ttl::insertNode&lt;hed::TTLtraits&gt;(dart, *point);
  
  <span class="comment">// Locate a triangle in the triangulation containing the given point.</span>
  <span class="comment">// The given dart will be repositioned to that triangle while maintaining</span>
  <span class="comment">// its orientation (CCW or CW).</span>
  <span class="comment">// If the given point is outside the triangulation, the dart will be</span>
  <span class="comment">// positioned at a boundary edge.</span>
  point-&gt;<a class="code" href="classhed_1_1Node.html#ecf4e4b054c363b753812c28f5c00a21">init</a>(0.5, 0.5, 0);
  <span class="keywordtype">bool</span> found = ttl::locateTriangle&lt;hed::TTLtraits&gt;(*point, dart);
  <span class="keywordflow">if</span> (!found) {
    cout &lt;&lt; <span class="stringliteral">"The given points is outside the triangulation"</span> &lt;&lt; endl;
    <span class="comment">// (and the dart is positioned at a boundary edge)</span>
    exit(-1);
  }
  
  <span class="comment">// The degree (or valency) of a node V in a triangulation, is defined</span>
  <span class="comment">// as the number of edges incident with V.</span>
  <span class="comment">// Get the degree of the node associated with the dart.</span>
  <span class="keywordtype">int</span> degree = <a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl.html#6b6626cfe11df135e5f9f64bb6887a8a">ttl::getDegreeOfNode</a>(dart);
  cout &lt;&lt; <span class="stringliteral">"Degree of node = "</span> &lt;&lt; degree &lt;&lt; endl;

  <span class="comment">// Check if the edge associated with the dart is at the boundary of the triangulation.</span>
  <span class="keywordflow">if</span> (<a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl.html#0005ecaf3d54298da01be64ea6b474a8">ttl::isBoundaryEdge</a>(dart))
    cout &lt;&lt; <span class="stringliteral">"The edge is at the boundary"</span> &lt;&lt; endl;

  <span class="comment">// Check if the node associated with the dart is at the boundary of the triangulation.</span>
  <span class="keywordflow">if</span> (<a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl.html#9eba6026cb5037c2e9ad5d203c1257ab">ttl::isBoundaryNode</a>(dart))
    cout &lt;&lt; <span class="stringliteral">"The node is at the boundary"</span> &lt;&lt; endl;

  <span class="comment">// Remove the node associated with the dart used above.</span>
  ttl::removeNode&lt;hed::TTLtraits&gt;(dart);
  
  <span class="comment">// Get the boundary of the triangulation represented as a list of darts.</span>
  <span class="comment">// Start with an arbitrary dart at the boundary.</span>
  edge = triang.getBoundaryEdge();
  <a class="code" href="classhed_1_1Dart.html">hed::Dart</a> b_dart(edge);
  list&lt;hed::Dart&gt; boundary;
  <a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl.html#0ec704f9c10a79e00e4765388259cbc0">ttl::getBoundary</a>(b_dart,boundary);
  cout &lt;&lt; <span class="stringliteral">"No. of edges on boundary = "</span> &lt;&lt; boundary.size() &lt;&lt; endl;

  <span class="comment">// Check if the triangulation is Delaunay</span>
  <span class="comment">// (This is not a TTL function)</span>
  <span class="keywordflow">if</span> (triang.checkDelaunay())    
    cout &lt;&lt; <span class="stringliteral">"Triangulation is Delaunay"</span> &lt;&lt; endl;
  <span class="keywordflow">else</span>
    cout &lt;&lt; <span class="stringliteral">"WARNING: Triangulation is not Delaunay"</span> &lt;&lt; endl;

  <span class="comment">// Insert two nodes and then insert a constrained edge between them</span>
  <span class="comment">// (Note that this could also be implemented in the code for the data structure.</span>
  <span class="comment">//  Here we call ttl directly to demonstrate the generic concept.) </span>
  <a class="code" href="classhed_1_1Dart.html">hed::Dart</a> d1 = triang.createDart(); <span class="comment">// an arbitrary CCW dart</span>
  ttl::insertNode&lt;hed::TTLtraits&gt;(d1, *<span class="keyword">new</span> <a class="code" href="classhed_1_1Node.html">hed::Node</a>(0.1, 0.25, 0));
  <a class="code" href="classhed_1_1Dart.html">hed::Dart</a> d2 = triang.createDart();
  ttl::insertNode&lt;hed::TTLtraits&gt;(d2, *<span class="keyword">new</span> <a class="code" href="classhed_1_1Node.html">hed::Node</a>(0.6, 0.85, 0));
  <span class="comment">// (Note that d1 is not necessarily valid after having inserted d2 since insertion</span>
  <span class="comment">//  of d2 may affect d1. Here d2 is "far from" d1, so we are relatively safe).</span>
  <span class="keywordtype">bool</span> <a class="codeRef" doxygen="tagfile_ttl:../../ttl_doc/html/" href="../../ttl_doc/html/namespacettl.html#190da335d29a65ce524868714ff3614c">optimizeDelaunay</a> = <span class="keyword">true</span>; <span class="comment">// optimizes to a constrained Delaunay triangulation</span>
  dart = ttl::insertConstraint&lt;hed::TTLtraits&gt;(d1, d2, optimizeDelaunay);

  <span class="comment">// Set the edge as constrained (fixed) such that it is not swapped when inserting nodes later</span>
  dart.getEdge()-&gt;setConstrained();

  <span class="comment">// Insert nodes and a constraint near that above to demonstrate fixed edges</span>
  d1 = triang.createDart();
  ttl::insertNode&lt;hed::TTLtraits&gt;(d1, *<span class="keyword">new</span> <a class="code" href="classhed_1_1Node.html">hed::Node</a>(0.35, 0.56, 0));
  d2 = triang.createDart();
  ttl::insertNode&lt;hed::TTLtraits&gt;(d2, *<span class="keyword">new</span> <a class="code" href="classhed_1_1Node.html">hed::Node</a>(0.1, 0.9, 0));
  dart = ttl::insertConstraint&lt;hed::TTLtraits&gt;(d1, d2, optimizeDelaunay);
  dart.getEdge()-&gt;setConstrained();

  <span class="comment">// Check if the boundary is convex (in the plane)</span>
  <span class="keywordflow">if</span> (ttl::convexBoundary&lt;hed::TTLtraits&gt;(b_dart))
    cout &lt;&lt; <span class="stringliteral">"\nBoundary is convex:"</span> &lt;&lt; endl;

  <span class="comment">// Print the nodes at the boundary</span>
  list&lt;hed::Dart&gt;::const_iterator it;
  <span class="keywordflow">for</span> (it = boundary.begin();  it != boundary.end(); ++it)
    cout &lt;&lt; it-&gt;getNode()-&gt;x() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; it-&gt;getNode()-&gt;y() &lt;&lt; <span class="charliteral">'\n'</span>;
  
  <span class="comment">// Print the triangulation (its edges)  to file</span>
  <span class="comment">// (for gnuplot or other line drawing programs)</span>
  cout &lt;&lt; <span class="stringliteral">"\nPrinting edges to file qweEdges.dat..."</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">"Plot triangulation with: gnuplot qwe.gnu"</span> &lt;&lt; endl;

  ofstream ofile(<span class="stringliteral">"qweEdges.dat"</span>);
  triang.printEdges(ofile);
  
  <span class="keywordflow">return</span> 0;
}
</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Wed Sep 19 15:15:01 2007 for Half-Edge by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
